import pickle
import shutil
import string

from ortools.sat.python import cp_model
from tqdm import tqdm

from disassembly_types import Variable

with open("generated_data/variables.pickle", "rb") as f:
    variables: list[Variable] = pickle.load(f)


chars = set(string.printable)
chars.remove("\t")
chars.remove("\n")
chars.remove("\x0b")
chars.remove("\x0c")
chars.remove("\r")
input_domain = sorted(ord(c) for c in chars)
print(input_domain)
input_min = min(input_domain)
input_max = max(input_domain)
print(f"range = [{input_min}, {input_max}]")
assert input_domain == list(range(input_min, input_max + 1))

# DEBUG:
# input_min, input_max = 0, 255


from generated_data.max_out_value_map import max_out_value_map  # noqa: E402

# max_out_value_map = {}  # noqa: F811


def write_map():
    with open("max_out_value_map-tmp.py", "w") as f:
        f.write("# AUTO-GENERATED BY solve_activation_domains_reduced.py\n")
        f.write(f"max_out_value_map = {max_out_value_map!r}\n")
    shutil.move("max_out_value_map-tmp.py", "max_out_value_map.py")
    print(f"Wrote max_out_value_map.py ({len(max_out_value_map)=})")


for target_var_index, target_var in enumerate(tqdm(variables)):
    key = (target_var_index, target_var.name)

    # Special-case the last variable, because CP-SAT is not able to solve it (quickly).
    if target_var.name == "x5440_0":
        max_out_value_map[key] = 1

    if key in max_out_value_map:
        solved_max_value = target_var.max_value = max_out_value_map[key]
    elif target_var.is_max_value_tight:
        solved_max_value = target_var.max_value
    else:
        # print("Building model...")
        model = cp_model.CpModel()

        var_index_to_cp_var: dict[int, cp_model.IntVar] = {}
        expanded_vars: set[int] = set()

        def get_cp_var(var_index: int, max_depth: int) -> cp_model.IntVar:
            var = variables[var_index]
            if (
                not (var.is_max_value_tight or var.value is None)
                and var.value.max_value(variables) < var.max_value
            ):
                print(f"{var.value.max_value(variables)=} < {var.max_value=}")
            if var_index not in var_index_to_cp_var:
                ub = (
                    var.max_value
                    if var.is_max_value_tight or var.value is None
                    else min(var.max_value, max(0, var.value.max_value(variables)))
                )
                var_index_to_cp_var[var_index] = model.new_int_var(var.min_value, ub, var.name)

            if max_depth > 0 and (var.value is not None) and (var_index not in expanded_vars):
                expanded_vars.add(var_index)
                linear_expr = (
                    sum(
                        coef * get_cp_var(var_index, max_depth - 1)
                        for var_index, coef in var.value.terms
                    )
                    + var.value.constant
                )
                model.add_max_equality(var_index_to_cp_var[var_index], [0, linear_expr])

            return var_index_to_cp_var[var_index]

        target = get_cp_var(target_var_index, max_depth=3)
        # print(f"{len(var_index_to_cp_var)} vars in model, {len(expanded_vars)} expanded")

        # print("Solving...")
        model.maximize(target)

        solver = cp_model.CpSolver()
        # solver.parameters.log_search_progress = True
        solver.parameters.max_presolve_iterations = 3
        solver.parameters.max_memory_in_mb = 3_000

        status = solver.solve(model)
        # print(f"{solver.wall_time = }")

        if status == cp_model.OPTIMAL:
            solved_max_value = solver.value(target)
        else:
            print(f"{(status == cp_model.OPTIMAL) = }")
            print(f"{(status == cp_model.FEASIBLE) = }")
            print(f"{(status == cp_model.INFEASIBLE) = }")
            print(f"{(status == cp_model.UNKNOWN) = }")
            raise Exception("infeasible")

    max_out_value_map[key] = solved_max_value
    better = (
        f"    *** BETTER THAN {target_var.max_value}"
        if solved_max_value < target_var.max_value
        else ""
    )
    target_var.max_value = solved_max_value
    if better:
        print(f"max_out_value_map[{key}] = {max_out_value_map[key]}{better}")

    if target_var_index % 500 == 0:
        write_map()

    # break

write_map()
print("\nAll done.")
